// ===== SIMULACIÓN INVENTARIO – alto: (t+1=30%) + bajo: (t+1=+50%) + demanda clip ±2σ =====
mode(-1);
funcprot(0);

// ---------- UTILIDADES ----------
function safe_seed(seed)
    if argn(2) == 0 then return; end
    if ~isnum(seed) then return; end
    try
        grand("setsd", seed);
    catch
        try
            rand("seed", seed);
        catch
            // sin seed reproducible
        end
    end
endfunction

function z = dow(t)
    z = modulo(t-1, 7) + 1; // 1=Lun .. 7=Dom
endfunction

function n = safe_round_pos(x)
    n = max(0, round(x));
endfunction

// ---------- FUNCIÓN PRINCIPAL ----------
function [res] = sim_fixed_receipt_combo(params)
    // params requeridos:
    //  days, mu, sigma, season[1x7], receipt_plan[1x7], receipt_cap, init_inv
    // params opcionales:
    //  high_threshold (default 200)   -> t+1 factor high_factor (p.ej. 0.3)
    //  high_factor (default 0.3)
    //  low_threshold  (default 128)   -> t+1 factor low_factor  (p.ej. 1.5)
    //  low_factor     (default 1.5)
    //  range_low (default 128), range_high (default 256)
    //  demand_clip_sigmas (default 2) -> recorte ±kσ con estacionalidad
    //  seed

    // Semilla
    if isfield(params, "seed") then
        safe_seed(params.seed);
    end

    // Parámetros base
    days   = params.days;
    mu     = params.mu;
    sigma  = params.sigma;
    season = params.season;
    cap    = params.receipt_cap;
    plan   = params.receipt_plan;
    onhand = params.init_inv;

    // Defaults manuales
    if isfield(params, "high_threshold") then high_thr = params.high_threshold; else high_thr = 200; end
    if isfield(params, "high_factor")    then high_factor = params.high_factor; else high_factor = 0.3; end

    if isfield(params, "low_threshold")  then low_thr = params.low_threshold;   else low_thr = 128; end
    if isfield(params, "low_factor")     then low_factor = params.low_factor;   else low_factor = 1.5; end

    if isfield(params, "range_low")      then lo = params.range_low;            else lo = 128; end
    if isfield(params, "range_high")     then hi = params.range_high;           else hi = 256; end

    if isfield(params, "demand_clip_sigmas") then ksig = params.demand_clip_sigmas; else ksig = 2; end

    // Validaciones
    if size(season,"*") <> 7 then error("season debe tener 7 elementos."); end
    if size(plan,"*")   <> 7 then error("receipt_plan debe tener 7 elementos."); end
    if sigma < 0 then error("sigma debe ser >= 0."); end
    if cap   < 0 then error("receipt_cap debe ser >= 0."); end

    // Inicializar vectores
    demand    = zeros(days,1);
    received  = zeros(days,1);
    served    = zeros(days,1);
    lost      = zeros(days,1);
    stockout  = zeros(days,1);
    onhand_v  = zeros(days,1);

    // Flags y logs
    high_next_flag = zeros(days,1);  // t+1: factor high_factor (p.ej. 0.3)
    high_trig_log  = [];             // días t donde se activa regla alta
    high_next_log  = [];             // días t+1 con factor alto

    low_next_flag  = zeros(days,1);  // t+1: factor low_factor (p.ej. 1.5)
    low_trig_log   = [];             // días t donde se activa regla baja
    low_next_log   = [];             // días t+1 con factor bajo (+50%)

    // --- Simulación principal ---
    for t = 1:days
        w = dow(t);

        // 1) Recepción con prioridades (t+1 flags)
        rcv_plan = plan(w);
        factor = 1;

        // Si hay ambas reglas en el mismo día t+1, aplicamos el MAYOR factor (low 1.5 > high 0.3)
        if high_next_flag(t) == 1 then
            factor = high_factor;
        end
        if low_next_flag(t) == 1 then
            factor = max(factor, low_factor);
        end

        // === RECEPCIÓN AJUSTADA A CAMIONES COMPLETOS (28 t) ===
        rcv_raw = factor * rcv_plan;               // cantidad sugerida
        rcv_adj = floor(rcv_raw / 28) * 28;        // redondeo a múltiplo de 28
        rcv = min(rcv_adj, cap);                   // respetar capacidad máxima
// ======================================================
        received(t) = rcv;
        onhand      = onhand + rcv;

        // 2) Demanda con estacionalidad + CLIP ±ksig*σ (Opción A)
        season_mu    = mu    * season(w);
        season_sigma = sigma * season(w);
        y = (mu + sigma * rand(1,1,"normal")) * season(w); // normal estacional
        lower = season_mu - ksig * season_sigma;
        upper = season_mu + ksig * season_sigma;
        y = min(max(y, lower), upper); // recorte a ±ksigσ
        d = safe_round_pos(y);
        demand(t) = d;

        // 3) Atención (sin backorders)
        sell      = min(onhand, d);
        served(t) = sell;
        lost(t)   = d - sell;
        onhand    = onhand - sell;
        if lost(t) > 0 then stockout(t) = 1; end

        onhand_v(t) = onhand;

        // 4) Programación de eventos desde el CIERRE de hoy (todos para t+1)
        //    a) Stock alto => t+1 factor high_factor
        if onhand >= high_thr then
            high_trig_log = [high_trig_log; t];
            if (t+1) <= days then
                high_next_flag(t+1) = 1;
                high_next_log       = [high_next_log; t+1];
            end
        end

        //    b) Stock bajo => t+1 factor low_factor (+120%)
        if onhand <= low_thr then
            low_trig_log = [low_trig_log; t];
            if (t+1) <= days then
                low_next_flag(t+1) = 1;
                low_next_log       = [low_next_log; t+1];
            end
        end
    end

    // KPI rango [lo, hi]
    mask_between = (onhand_v >= lo) & (onhand_v <= hi);
    between_idx  = find(mask_between);
    days_between = size(between_idx, "*");
    pct_in_range = 100 * days_between / max(1, days); // % de días en rango

    // Días con stock > 650 t
    mask_gt650 = (onhand_v > 650);
    idx_gt650  = find(mask_gt650);
    days_gt650 = size(idx_gt650, "*");

    // Días con quiebre
    stockout_idx = find(lost > 0);

    // Resultados
    res = struct( ...
        "demand",              demand, ...
        "received",            received, ...
        "served",              served, ...
        "lost",                lost, ...
        "onhand",              onhand_v, ...
        "stockout_days",       sum(stockout), ...
        "stockout_idx",        stockout_idx', ...
        "fill_rate",           sum(served) / max(1, sum(demand)), ...
        "ending_onhand",       onhand, ...
        "high_threshold",      high_thr, ...
        "high_factor",         high_factor, ...
        "low_threshold",       low_thr, ...
        "low_factor",          low_factor, ...
        "high_triggers_count", size(high_trig_log,"*"), ...
        "high_trigger_days",   high_trig_log', ...
        "high_next_count",     size(high_next_log,"*"), ...
        "high_next_days",      high_next_log', ...
        "low_triggers_count",  size(low_trig_log,"*"), ...
        "low_trigger_days",    low_trig_log', ...
        "low_next_count",      size(low_next_log,"*"), ...
        "low_next_days",       low_next_log', ...
        "range_low",               lo, ...
        "range_high",              hi, ...
        "days_stock_in_range",     days_between, ...
        "pct_days_in_range",       pct_in_range, ...
        "days_in_range_idx",       between_idx', ...
        "days_stock_gt650",        days_gt650, ...
        "days_gt650_idx",          idx_gt650', ...
        "demand_clip_sigmas",      ksig ...
    );
endfunction

// ---------- PARÁMETROS ----------
params = struct();
params.days          = 365;
params.mu            = 115.7454936;
params.sigma         = 64.00585279;
params.season        = [1.07, 1.23, 1.10, 1.11, 1.11, 0.41, 0.00];
params.receipt_cap   = 308;
params.receipt_plan  = [160, 128, 160, 128, 128, 0, 0];
params.init_inv      = 400;
params.high_threshold= 500;   // t+1 => 80% (high_factor)
params.high_factor   = 0.2;
params.low_threshold = 300;   // t+1 => +50% (low_factor)
params.low_factor    = 1.5;
params.range_low     = 300;
params.range_high    = 500;
params.demand_clip_sigmas = 2; // recorte ±2σ
// params.seed       = 12345;

// ---------- CORRER ----------
try
    res = sim_fixed_receipt_combo(params);

    mprintf("\n--- RESULTADOS ---\n");
    mprintf("Días con quiebre:                    %d\n", res.stockout_days);
    mprintf("Fill rate:                           %.2f %%\n", 100*res.fill_rate);
    mprintf("Stock final:                         %.2f t\n", res.ending_onhand);
    mprintf("Demanda recortada a ±%gσ\n", res.demand_clip_sigmas);
    mprintf("Regla alto:  stock >= %d → t+1 = %.0f%% del plan\n", res.high_threshold, 100*res.high_factor);
    mprintf("Regla bajo:  stock <= %d → t+1 = +%.0f%% sobre el plan\n", res.low_threshold, 100*(res.low_factor-1));
    mprintf("Activaciones alto (t):               %d\n", res.high_triggers_count);
    mprintf("Activaciones bajo (t):               %d\n", res.low_triggers_count);
    mprintf("Días con stock en [%d–%d]:           %d (%.2f %%)\n", ...
            res.range_low, res.range_high, res.days_stock_in_range, res.pct_days_in_range);
    mprintf("Días con stock > 650 t:              %d\n", res.days_stock_gt650);

    // Helper visual (columnas de 12)
    function show_list(title, vec)
        if size(vec,"*") > 0 then
            mprintf("%s\n", title);
            idx = vec';
            for k = 1:12:length(idx)
                fin = min(k+11, length(idx));
                line = strcat(string(idx(k:fin))', " ");
                mprintf("%s\n", line);
            end
        end
    endfunction
    
    // ===== MOSTRAR VENTANAS DE ±4 DÍAS PARA CADA QUIEBRE =====
if size(res.stockout_idx, "*") > 0 then
    mprintf("\n=== Ventanas de quiebre (±4 días) ===\n");

    for k = 1:size(res.stockout_idx, "*")
        t = res.stockout_idx(k);   // día de quiebre

        // límites de ventana
        t_inicio = max(1, t-4);
        t_fin    = min(params.days, t+4);

        mprintf("\nQuiebre en día %d — ventana %d a %d:\n", t, t_inicio, t_fin);

        // construir tabla
        dias      = (t_inicio:t_fin)';
        demanda   = res.demand(t_inicio:t_fin);
        recibido  = res.received(t_inicio:t_fin);
        stock     = res.onhand(t_inicio:t_fin);

        tabla = [ dias demanda recibido stock ];
        disp(tabla, "   Día   Demanda   Recibido   Stock");
    end
else
    mprintf("\nNo hubo días de quiebre.\n");
end


    // Si querés listar días concretos (descomentar lo que necesites):
    // show_list("Días activación ALTO (t):", res.high_trigger_days);
    // show_list("Días con factor alto (t+1):", res.high_next_days);
    // show_list("Días activación BAJO (t):", res.low_trigger_days);
    // show_list("Días con factor bajo (t+1):", res.low_next_days);
    // show_list("Días con stock en rango:", res.days_in_range_idx);

    // Gráfico de stock
    scf();
    plot(1:params.days, res.onhand);
    xlabel("Día"); ylabel("Inventario (t)");
    title("Inventario diario con reglas alto/bajo t+1");
    xgrid();
    
    // Mostrar días de quiebre
if size(res.stockout_idx, "*") > 0 then
    show_list("Días con quiebre:", res.stockout_idx);
else
    mprintf("No hubo quiebres.\n");
end

// Mostrar días con stock > 650 t
if res.days_stock_gt650 > 0 then
    show_list("Días con stock > 650 t:", res.days_gt650_idx);
else
    mprintf("No hubo días con stock > 650 t.\n");
end

catch
    mprintf("\n*** ERROR EN EJECUCIÓN ***\n");
    disp(lasterror());
end
